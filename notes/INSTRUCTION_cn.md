/*
    Generated by Claude 3.5
*/

CUDA 入门 - 群集模拟
============================

提交截止日期: 2024年9月8日(周日)

**概述:** 在这个项目中,你将获得编写简单 CUDA 内核、使用它们并分析其性能的实际经验。你将基于 Reynolds Boids 算法实现一个群集模拟,并完成两个层次的优化:均匀网格和具有半相干内存访问的均匀网格。

## Part 0: 前期准备

本项目(以及本课程的所有其他 CUDA 项目)需要一个支持 CUDA 的 NVIDIA 显卡。任何具有 Compute Capability 3.0(GTX 6xx 及更新)或更高版本的显卡都可以使用。你可以在这个[兼容性表格](https://developer.nvidia.com/cuda-gpus)中查看你的 GPU。如果你没有符合这些规格的个人电脑,你可以使用 Moore 100B/C 中配备了支持 GPU 的电脑,但请密切注意下面的**设置**部分。

**注意**: 如果你需要使用实验室电脑进行开发,你目前将无法进行 GPU 性能分析。这对于调试程序的性能瓶颈非常重要。如果你没有任何支持 CUDA 的机器的管理员权限,请发邮件给助教。

## Part 1: 基础 Boids 模拟

### 1.0. 基本设置

参考 Project 0 的 Part 1-3。

如果你使用的是 Nsight IDE(而不是 Visual Studio)并且很早就开始了 Project 0,请注意现在有一些变化。不要创建新项目,而是使用 *File->Import->General->Existing Projects Into Workspace*,并选择项目文件夹作为根目录。在 *Project->Build Configurations->Set Active...* 中,你现在可以选择各种 Release 和 Debug 版本。

* `src/` 包含源代码
* `external/` 包含 GLEW、GLFW 和 GLM 的二进制文件和头文件

**CMake 注意事项:** 不要直接在项目中更改任何构建设置或添加任何文件(在 Visual Studio、Nsight 等中)。相反,请编辑 `CMakeLists.txt` 文件。你创建的任何文件都必须添加到这里。如果你编辑了它,只需重新构建你的 VS/Nsight 项目即可将更改同步到 IDE 中。

请在不做任何修改的情况下运行项目,以确保一切正常工作。我们在 `kernel.cu` 中提供了一个运行测试代码的空间,目前它包含了一个如何使用 `Thrust` 库在 GPU 上执行键值排序的示例。如果一切正常,你应该能在控制台窗口中看到一些输出,以及一个灰色粒子组成的立方体。查看器配备了相机控制:左键单击并拖动可以移动相机视角,右键单击并垂直拖动可以放大和缩小。

**注意: 为了性能分析和捕获,请在 `release` 模式下构建项目。**

### 1.1. 使用朴素邻居搜索的 Boids

在 Boids 群集模拟中,代表鸟类或鱼类的粒子(boids)根据以下三个规则在模拟空间中移动:

1. 内聚 - boids 向其邻居的感知质心移动
2. 分离 - boids 避免与邻居靠得太近
3. 对齐 - boids 通常试图与邻居保持相同的方向和速度

这三个规则指定了一个 boid 在一个时间步长内的速度变化。
在每个时间步长,一个 boid 必须查看其每个相邻的 boid,并计算来自这三个规则的速度变化贡献。
因此,一个基本的 boids 实现需要每个 boid 检查模拟中的每个其他 boid。

这里有一些快速伪代码来帮助你:

#### 规则 1: Boids 试图飞向邻近 boids 的质心

```
function rule1(Boid boid)

    Vector perceived_center

    foreach Boid b:
        if b != boid and distance(b, boid) < rule1Distance then
            perceived_center += b.position
        endif
    end

    perceived_center /= number_of_neighbors

    return (perceived_center - boid.position) * rule1Scale
end
```

#### 规则 2: Boids 试图与其他物体(包括其他 boids)保持一定距离。

```
function rule2(Boid boid)

    Vector c = 0

    foreach Boid b
        if b != boid and distance(b, boid) < rule2Distance then
            c -= (b.position - boid.position)
        endif
    end

    return c * rule2Scale
end
```

#### 规则 3: Boids 试图与附近的 boids 保持相同的速度。

```
function rule3(Boid boid)

    Vector perceived_velocity

    foreach Boid b
        if b != boid and distance(b, boid) < rule3Distance then
            perceived_velocity += b.velocity
        endif
    end

    perceived_velocity /= number_of_neighbors

    return perceived_velocity * rule3Scale
end
```

基于 [Conard Parker 的笔记](http://www.vergenet.net/~conrad/boids/pseudocode.html) 并做了轻微调整。为了实现一个有趣的模拟,我们规定两个 boids 只有在彼此的某个**邻域距离**内才会相互影响。

我们还有一个用 Processing 实现的简单[2D 实现](http://studio.sketchpad.cc/sp/pad/view/ro.9cbgCRcgbPOI6/rev.23),在概念上与你将要编写的非常相似。你可以随意使用这个实现作为数学/代码参考。

要了解 3D 模拟"应该"是什么样子,[这里是我们参考实现的效果](https://vimeo.com/181547860)。

**请注意** 我们的伪代码、2D 实现和参考代码(我们从中得到了基础代码中的参数)在规则 3 中与 Conrad Parker 的笔记有所不同 - 我们的参考中没有从感知速度中减去 boid 自身的速度:

我们的伪代码:
```
    return perceived_velocity * rule3Scale
```
Conrad Parker 的笔记:
```
    RETURN (pvJ - bJ.velocity) / 8
```

这仅仅是因为制作参考的助教在最初创建这个项目时忽略了这个小细节,但结果看起来还不错 :facepalm:。

使用默认参数严格遵循 Conrad Parker 的伪代码可能会导致意外结果,你可以通过参数调整来解决这个问题。如果你找到了"更正确"的 Boids 实现的好参数,欢迎在 Piazza 上分享!

然而,由于这个作业的目的是让你熟悉 CUDA,我们建议你此时遵循我们的伪代码来实现算法,这样你就不必在调试实现时还要调整参数。

### 1.2. 代码导览

* `src/main.cpp`: 执行所有 CUDA/OpenGL 设置和 OpenGL 可视化。
* `src/kernel.cu`: CUDA 设备函数、状态、内核和用于内核调用的 CPU 函数。代替单元测试/沙盒框架,这里有空间可以在运行实际模拟之前单独运行你的内核并从 GPU 获取输出。请在 Part 2 中使用这个功能来单独测试你的内核。

1. 搜索代码中的 `TODO-1.2` 和 `LOOK-1.2`。
   * `src/kernel.cu`: 使用你在第一堂课中学到的知识来解决这些 Part 1 的 TODO。

### 1.3. 实验

我们提供的参数使用我们的参考实现可以得到一个稳定的模拟,但你的情况可能有所不同。尝试改变 boid 的数量,看看模拟如何响应。

## Part 2: 让群集更好!

### 2.0. 均匀网格的快速解释

回想 Part 1 中,任何两个 boids 只有在某个*邻域距离*内才能相互影响。
基于这个观察,我们可以看到让每个 boid 检查每个其他 boid 是非常低效的,特别是当(像我们的标准参数那样)boid 的数量很大而邻域距离远小于完整的模拟空间时。我们可以使用一个称为**均匀空间网格**的数据结构来减少邻居检查。

均匀网格由至少与邻域距离一样宽的单元格组成,覆盖整个模拟域。
在计算 boids 的新速度之前,我们在预处理步骤中将它们"分类"到网格中。
![2D 中的均匀网格](images/Boids%20Ugrid%20base.png)

如果单元格宽度是邻域距离的两倍,每个 boid 只需要检查 8 个单元格中的其他 boids,在 2D 情况下是 4 个。

![2D 中的均匀网格,显示了某些粒子的邻域和需要搜索的单元格](images/Boids%20Ugrid%20neighbor%20search%20shown.png)

你可以在 CPU 上通过遍历 boids,确定其所在的单元格,然后在代表该单元格的可调整大小的数组中保持指向该 boid 的指针来构建均匀网格。然而,这不能很好地转移到 GPU 上,因为:

1. 我们在 GPU 上没有可调整大小的数组
2. 简单地并行化迭代可能导致竞争条件,即两个粒子需要在同一时钟周期写入同一个桶中。

相反,我们将通过排序来构建均匀网格。如果我们用代表其所在单元格的索引标记每个 boid,然后按这些索引对 boids 列表进行排序,我们可以确保同一单元格中的 boid 指针在内存中是连续的。

然后,我们可以遍历排序后的均匀网格索引数组,查看每对值。如果值不同,我们知道我们处于两个不同单元格表示的边界。将这些位置存储在一个表中,每个单元格有一个条目,就给我们一个完整的均匀网格表示。这个"表"可以只是一个与单元格数量一样大的数组。
这个过程是数据并行的,可以简单地并行化。
![使用索引排序生成均匀网格的缓冲区](images/Boids%20Ugrids%20buffers%20naive.png)

### 2.1. 代码导览

我们不会让你在第一个作业中就实现 GPU 上的并行排序,而是使用内置在 **Thrust** 中的值/键排序。参见 `kernel.cu` 中的 `Boids::unitTest` 了解如何使用它。

你的均匀网格在 GPU 内存中可能看起来像这样:
- `dev_particleArrayIndices` - 包含每个 boid 在 dev_pos、dev_vel1 和 dev_vel2 中数据的指针的缓冲区
- `dev_particleGridIndices` - 包含每个 boid 的网格索引的缓冲区
- `dev_gridCellStartIndices` - 包含每个单元格在 `dev_particleArrayIndices` 中数据开始的指针的缓冲区
- `dev_gridCellEndIndices` - 包含每个单元格在 `dev_particleArrayIndices` 中数据结束的指针的缓冲区

这里当与缓冲区一起使用时,"指针"这个术语在很大程度上可以与"索引"这个术语互换,但是,你实际上将使用数组索引作为指针。

查看代码中 Part 2.1 的 TODOs 和 LOOKs 获取一些伪代码帮助。

你可以使用 `main.cpp` 中的定义在不同的时间步长更新模式之间切换。

### 2.2 继续实验

比较你的均匀网格速度更新和朴素速度更新。
在典型情况下,均匀网格版本应该快得多。
尝试推动你能模拟的 boids 数量的极限。

将均匀网格的单元格宽度改为邻域距离,而不是邻域距离的两倍。现在,需要检查 27 个相邻单元格是否有交集。这是增加还是减少了群集的效率?

### 2.3 去掉中间人

考虑 2.1 中概述的均匀网格邻居搜索:单个单元格中的 boid 指针在内存中是连续的,但 boid 数据本身(速度和位置)分散在各处。尝试重新排列 boid 数据本身,使一个单元格中所有 boids 的速度和位置也在内存中连续,这样就可以直接使用 `dev_gridCellStartIndices` 和 `dev_gridCellEndIndices` 访问这些数据,而不需要 `dev_particleArrayIndices`。

![使用索引排序生成均匀网格,然后使 boid 数据相干的缓冲区](images/Boids%20Ugrids%20buffers%20data%20coherent.png)

查看 Part 2.3 的 TODOs。这应该涉及对 2.1 中代码的略微修改版本。

## Part 3: 性能分析

对于这个项目,我们将通过一些基本问题来指导你进行性能分析。在未来,你将指导自己的性能分析 - 但这些简单的问题始终是关键的。一般来说,我们希望你超越建议的性能调查,探索代码的不同方面如何影响整体性能。

提供的帧率计(在窗口标题中)将是一个有用的基本指标,但添加你自己的 `cudaTimer` 等将允许你对代码的各个部分进行更细粒度的基准测试。

记住:
* 在 `Release` 模式下进行性能测试!
* 在 Nvidia 控制面板中关闭垂直同步:
![解锁 FPS](images/UnlockFPS.png)
* 性能应该始终在可能的情况下相对于某个基准来衡量。GPU 可以让你的程序更快 - 但快了多少?
* 如果一个更改影响了性能,显示一个比较。描述你的更改。
* 描述你用于基准测试的方法。
* 性能图表是好事。

### 问题

有两种方法来测量性能:
* 禁用可视化,这样报告的帧率将只针对模拟,而不会限制在 60 fps。这样,窗口标题中报告的帧率将是有用的。
  * 要做到这一点,将 `#define VISUALIZE` 改为 `0`。
* 为了更精确的时间测量,你可以使用 CUDA 事件来仅测量模拟 CUDA 内核。这方面的信息可以在网上轻松找到。你可能需要对几个模拟步骤取平均值,类似于当前计算 FPS 的方式。

这部分不会根据正确性进行评分,但请让我们知道你的假设和见解。

**回答这些问题:**

* 对于每种实现,改变 boids 的数量如何影响性能?你认为这是为什么?
* 对于每种实现,改变块数和块大小如何影响性能?你认为这是为什么?
* 对于相干均匀网格:你是否经历了任何性能改进?这是你预期的结果吗?为什么是或为什么不是?
* 改变单元格宽度和检查 27 个vs 8 个相邻单元格是否影响了性能?为什么是或为什么不是?要小心:仅仅说 27 个单元格更慢是因为有更多的单元格要检查是不够的(而且可能是错误的)!

**注意: Nsight 性能分析工具*目前*无法在实验室计算机上使用,因为它们需要管理员访问权限。** 如果你无法访问支持 CUDA 的计算机,实验室计算机仍然允许你进行时间测量!然而,这些工具对于性能调试非常有用。

## Part 4: 报告

1. 截取 boids 的截图**并**使用像 [licecap](http://www.cockos.com/licecap/) 这样的 gif 工具录制固定相机的动画。
将其放在你的 README.md 顶部。看看[如何制作一个有吸引力的 GitHub 仓库](https://github.com/pjcozzi/Articles/blob/master/CIS565/GitHubRepo/README.md)。
2. 添加你的性能分析。需要包含的图表:
- 朴素、分散均匀网格和相干均匀网格的帧率随 boids 数量增加的变化(有和没有可视化)
- 帧率随块大小增加的变化

## 提交

如果你修改了任何 `CMakeLists.txt` 文件(除了 `SOURCE_FILES` 列表),请明确提及。注意 Google Group 上讨论的任何构建问题。

打开一个 GitHub pull request,这样我们就可以看到你已经完成了。
标题应该是 "Project 1: 你的名字"。
你的 pull request 评论部分的模板如下,你可以复制粘贴:

* [仓库链接](到你仓库的链接)
* (简要)提到你已完成的功能。特别是那些你想要突出的额外功能
    * 功能 0
    * 功能 1
    * ...
* 对项目本身的反馈(如果有的话)。

就这样!

## 提示

- 如果你的模拟在启动前崩溃,在 CUDA 调用后使用 `checkCUDAErrorWithLine("message")`
- Visual Studio 中的 `ctrl + f5` 将启动程序但不会让窗口在程序崩溃时关闭。这样你就可以看到任何 `checkCUDAErrorWithLine` 输出。
- 出于调试目的,你可以在 GPU 之间传输数据。参见 `kernel.cu` 中的 `Boids::unitTest` 了解如何使用它。
- 对于高 DPI 显示器,如 4K 显示器或带有 Retina 显示屏的 Macbook Pro,你可能想要将渲染分辨率和点大小加倍。参见 `main.hpp`。
- 你的 README.md 将使用 github markdown 完成。你可以在[这里找到一个速查表](https://guides.github.com/pdfs/markdown-cheatsheet-online.pdf)。github 的 [atom 文本编辑器](https://atom.io/)也有一个[实时预览插件](https://atom.io/packages/markdown-preview)。[VS Code](https://www.visualstudio.com/en-us/products/code-vs.aspx) 也是如此
- 如果你的帧率被限制在 60fps,[禁用 V-sync](http://support.enmasse.com/tera/enable-v-sync-to-fix-graphics-issues-screen-tearing)

## 可选额外学分

* 共享内存优化:
    * 使用共享内存和均匀网格添加快速最近邻搜索。包括额外的图表和性能分析,清楚地显示使用共享内存后程序的性能提升了多少。
* 网格循环优化:
    * 不要硬编码指定区域的搜索,而是根据网格单元格在 max_distance 内有任何部分来限制搜索区域。这可以防止与每个网格单元格的角点进行过多的位置比较,同时也允许更灵活的方法(因为我们只是在所有三个基本方向上定义一个最小单元格索引和最大单元格索引)。也就是说,不再需要手动检查特定数量的周围单元格(如 8 个周围单元格、27 个周围单元格等)。 